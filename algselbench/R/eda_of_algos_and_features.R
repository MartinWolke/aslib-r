#' Creates a table that gives an overview of the performance values per algorithm across all instances.
#'
#' @param astask [\code{\link{ASTask}}]\cr
#'   Algorithm selection task.
#' @return [\code{data.frame}]. 
#'  Data frame, which gives an overview of the performance values.
#' @export
summarizeAlgoRuns = function(astask, measure) {
  checkArg(astask, "ASTask")
  data = astask$algo.runs
  if (missing(measure))
    measure = astask$desc$performance_measures[1]
  else
    checkArg(measure, "character", len = 1L, na.ok = FALSE)
  return(summarizeAlgos(data, measure))
}

summarizeAlgos = function(data, measure) {
  split_all = split(data, data$algorithm)
  split_all = c(split_all, allAlgorithms = list(data))
  var_coeff = function(x) sd(x) / mean(x)
  solved = function(x) 100 * mean(as.character(x) == "ok")
  foo = function(x, aggr) {
    aggr(na.omit(x[[measure]]))
  }
  result = sapply(split_all, function(z) foo(z, min))
  result = cbind(result, sapply(split_all, function(z) foo(z, function(a) quantile(a, 0.25))))
  result = cbind(result, sapply(split_all, function(z) foo(z, median)))
  result = cbind(result, sapply(split_all, function(z) foo(z, mean)))
  result = cbind(result, sapply(split_all, function(z) foo(z, function(a) quantile(a, 0.75))))
  result = cbind(result, sapply(split_all, function(z) foo(z, max)))
  result = cbind(result, sapply(split_all, function(z) foo(z, sd))) 
  result = cbind(result, sapply(split_all, function(z) foo(z, var_coeff))) 
  result = cbind(result, sapply(split_all, function(z) sum(is.na(z[[measure]])))) 
  result = cbind(result, sapply(split_all, nrow))
  result = cbind(result, sapply(split_all, function(z) solved(z$runstatus)))
  colnames(result) = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.", "Std. Dev.", "CoV.", "NA's", 
                       "Obs.", "Run OK (%)")
  return(as.data.frame(result))
}


#' Creates a table that gives an overview of the feature values across all instances.
#'
#' @param astask [\code{\link{ASTask}}]\cr
#'   Algorithm selection task.
#' @return [\code{data.frame}]. 
#'  Overview of the feature values.
#' @export
summarizeFeatureValues = function(astask) {
  checkArg(astask, "ASTask")
  featValues = astask$feature.values
  featStatus = astask$feature.runstatus
  return(summarizeFeatures(featValues[,-c(1:2)], featStatus[,-c(1:2, ncol(featStatus))]))
}


summarizeFeatures = function(values, status) {
  var_coeff = function(x) sd(x) / mean(x)
  foo = function(x, aggr) {
    aggr(na.omit(x))
  }
  result = sapply(values, function(z) foo(z, min))
  result = cbind(result, sapply(values, function(z) foo(z, function(a) quantile(a, 0.25))))
  result = cbind(result, sapply(values, function(z) foo(z, median)))
  result = cbind(result, sapply(values, function(z) foo(z, mean)))
  result = cbind(result, sapply(values, function(z) foo(z, function(a) quantile(a, 0.75))))
  result = cbind(result, sapply(values, function(z) foo(z, max)))
  result = cbind(result, sapply(values, function(z) foo(z, sd))) 
  result = cbind(result, sapply(values, function(z) foo(z, var_coeff))) 
  result = cbind(result, sapply(values, function(z) sum(is.na(z)))) 
  result = cbind(result, sapply(values, length))
  result = cbind(result, sapply(status, function(z) 100 * mean(as.character(z) == "ok")))
  colnames(result) = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.", "Std. Dev.", "CoV.", "NA's", 
                       "Obs.", "Run OK (%)")
  return(as.data.frame(result))
}

#' Creates a table that shows the dominance of one algorithm over another one.
#'
#' @param astask [\code{\link{ASTask}}]\cr
#'   Algorithm selection task.
#' @return [\code{data.frame}]. 
#'  Overview of the dominance between the algorithms.
#' @export
dominatedAlgos = function(astask){
  checkArg(astask, "ASTask")
  data = astask$algo.runs
  splittedData = split(data, data$algorithm)
  algoNames = names(splittedData)
  algoNr = length(algoNames)
  result = c(Superior = "none", Inferior = "none")
  for(i in 1:(algoNr - 1)){
    alg1 = splittedData[[i]]
    for(j in (i+1):algoNr){
      alg2 = splittedData[[j]]
      result = rbind(result, dominating(alg1, alg2, algoNames[c(i, j)]))
    }
  }
  result = as.data.frame(result)
  if(nrow(result) == 1) {
    rownames(result) = 1
    return(result)
  }
  result = result[-1, ]
  result = result[order(result[,1]), ]
  rownames(result) = 1:nrow(result)
  return(result)
}

dominating = function(x, y, names){
  x$solved = (as.character(x$runstatus) == "ok")
  y$solved = (as.character(y$runstatus) == "ok")
  index = (x$solved | y$solved)
  if(sum(index) == 0) return(NULL)
  xRed = x[index,]
  yRed = y[index,]
  supAlgo = NULL
  infAlgo = NULL
  result = NULL
  if(all(xRed$solved) & (all(xRed[yRed$solved, "runtime"] <= yRed[yRed$solved, "runtime"])))
    return(c(supAlgo = names[1], infAlgo = names[2]))
  if(all(yRed$solved) & (all(yRed[xRed$solved, "runtime"] <= xRed[xRed$solved, "runtime"])))
    return(c(supAlgo = names[2], infAlgo = names[1]))
  return(result)
}



#' Checks the feature data set for duplicated instances.
#'
#' @param astask [\code{\link{ASTask}}]\cr
#'   Algorithm selection task.
#' @return Printed output of blocks of duplicated features (if existing).
#' @export
checkDuplicates = function(astask){
  checkArg(astask, "ASTask")
  data = astask$feature.values
  origData = data
  origObsNr = nrow(origData)
  data = data[!duplicated(data[,"instance_id"]),]
  label = as.character(data[,"instance_id"])
  data = data[, setdiff(colnames(data), "instance_id")]
  uniqueObsNr = nrow(data)
  dupl = duplicated(data)
  totalDuplicates = sum(dupl)
  if(uniqueObsNr != origObsNr) 
    catf("%i instances were used, although only %i different instances exist.\n", origObsNr, uniqueObsNr)
  if(totalDuplicates == 0) { 
    if(uniqueObsNr == origObsNr) {
      cat("Did not recognize any duplicated features.")
    } else {
      cat("(Note: Those duplicates usually result from replications.)")
    }
    return(NULL)
  } else {
    result = NULL
    block = NULL
    blocks = 0
    maxInst = 0
    instNr = NULL
    existingNAs = any(is.na(data))
    while(any(dupl)){
      blocks = blocks + 1
      compareTo = which(dupl)[1]
      if(existingNAs) {
        x = as.character(data[compareTo, ])
        duplicates = logical(uniqueObsNr)
        for(i in 1:uniqueObsNr) 
          duplicates[i] = all(as.character(data[i,]) == x)  
      } else {
        x = data[compareTo, ]
        duplicates = apply(data, 1, function(z) all(z == x))
      }
      block = c(block, rep(blocks, length = sum(duplicates)), "")
      result = c(result, label[duplicates], "")
      duplNr = sum(duplicates)
      instNr = c(instNr, (maxInst + 1) : (maxInst + duplNr), "")
      maxInst = maxInst + duplNr
      dupl[duplicates] = FALSE
    }
    if(blocks > 1){
      catf("The following %i instances result in %i blocks of duplicated features:", 
           blocks + totalDuplicates, blocks)
    } else {
      catf("The features of the following %i instances are duplicates of each other:", 
           blocks + totalDuplicates)
    }
    #for(response in result){
    #  catf("%s", response)
    #}
    result = cbind(block = block, instNr = instNr, duplicates = result)
    result = result[-nrow(result),]
    result = as.data.frame(result)
    result$block = as.character(result$block)
    result$instNr = as.character(result$instNr)
    result$duplicates = as.character(result$duplicates)
    colnames(result) = c("Block", "Inst. No.", "ID of duplicated feature")
    return(result)
  }
}


#' Checks algorithm and feature data sets for useless instances.
#'
#' @param astask [\code{\link{ASTask}}]\cr
#'   Algorithm selection task.
#' @return [\code{list}(3)]. 
#'  List of data frames, which give an overview of instances that consist of only one single value
#'  (and eventually some NAs) per instance.
#'  There output consists of three data frames: one for the algo runs, the feature values and the
#'  feature runstatus, respectively.
#' @export
uselessInstances = function(astask, measure) {
  checkArg(astask, "ASTask")
  if (missing(measure))
    measure = astask$desc$performance_measures[1]
  else
    checkArg(measure, "character", len = 1L, na.ok = FALSE)
  algoRuns = astask$algo.runs
  featVals = astask$feature.values
  featRuns = astask$feature.runstatus
  splittedAlgos = split(algoRuns[[measure]], algoRuns$algorithm)
  checkedAlgos = check4uniques(splittedAlgos)
  checkedAlgos = checkedAlgos[!((checkedAlgos$uniqueVal == -Inf) & (checkedAlgos$NAs == -Inf)),]
  colnames(checkedAlgos) = c("unique Value(s)", "NA's")
  checkedFeatVals = check4uniques(featVals)
  checkedFeatVals = checkedFeatVals[!((checkedFeatVals$uniqueVal == -Inf) & (checkedFeatVals$NAs == -Inf)),]
  colnames(checkedFeatVals) = c("unique Value(s)", "NA's")
  checkedFeatRuns = check4uniques(featRuns)
  checkedFeatRuns = checkedFeatRuns[!((checkedFeatRuns$uniqueVal == -Inf) & (checkedFeatRuns$NAs == -Inf)),]
  checkedFeatRuns = checkedFeatRuns[!((as.character(checkedFeatRuns$uniqueVal) == "ok") & 
                                        (checkedFeatRuns$NAs == 0)),]
  colnames(checkedFeatRuns) = c("unique Value(s)", "NA's")
  return(list(algo.runs = checkedAlgos, feature.values = checkedFeatVals, feature.runstatus = checkedFeatRuns))
}


check4uniques = function(data) {
  result = t(sapply(data, function(x) {
    if(is.factor(x)) x = as.character(x)
    NAs = is.na(x)
    woNAs = x[!NAs]
    if(length(unique(woNAs)) <= 1) {
      uniqueVal = unique(woNAs)
      if(length(uniqueVal) == 0) uniqueVal = NA
      return(c(uniqueValue = uniqueVal, NAs = sum(NAs)))
    } else {
      return(c(uniqueValue = -Inf, NAs = -Inf))
    }
  }))
  return(as.data.frame(result))
}
